<html>
	<head>
		<title>BBBBBB, a VVVVVV inspired game written in C with SDL2</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">	
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Inspired by Terry Cavanagh&#39;s recent open-sourcing of indie hit VVVVVV, I wrote my own take on the gravity flip platformer in C with SDL2">
		
		<meta property="og:title" content="BBBBBB, a VVVVVV inspired game written in C with SDL2">
		<meta property="og:type" content="article">
		<meta property="og:url" content="https://adamjrichardson.com/bbbbbb.html">
		<meta property="og:image" content="">
		<meta property="og:description" content="Inspired by Terry Cavanagh&#39;s recent open-sourcing of indie hit VVVVVV, I wrote my own take on the gravity flip platformer in C with SDL2">
	
		<style>
body { 
	color: black; 
	background-color: #eff4f3;
	font-family:  "Liberation Sans", Helvetica, "Trebuchet MS", sans-serif;
	margin: auto;
	padding: 1em;
	max-width: 72em;
}
 
pre { 
	background-color: black; 
	color: white; 
	font-size: 12pt; 
	padding: 1em;
	max-height: 50em;
	overflow: auto;
	-moz-tab-size: 2;
	tab-size: 2;
	font-family: monospace;
}

a {
	font-weight: bold;
	padding-right: .25em;
}

a:visited {
	color: black;
}

a:link {
	color: black;
}

img {
	max-width: 100%;
	margin-bottom: 1em;
	margin-right: 1em;
}

p {
	text-align: justify;
	line-height: 1.5em;
}

nav {
	width: 100%;
	text-align: right;
	margin-bottom: 2em;
}

ul {
}

li {
	margin-bottom: 1em;
}

.left {
	float: left;
}

.feature {
	width: 50%;
	margin: 0 25%;
}

.projects {
	display: flex;
	flex-wrap: wrap;
}

.project {
	display: inline-grid;
	margin: 1em;
}
.project > .container {
	width: 192px;
	height: 202px;
}

.project > a {
	line-height: 1.3em;
}
		</style>
	</head>
	<body>
		<nav>
			<a href="index.html">Home</a>
			<a href="about.html">About</a>
			<a href="projects.html">Projects</a>
			<a href="rss.xml">RSS</a>
			<a href="https://github.com/thales17">Github</a>
		</nav>
	
	
		<h1>BBBBBB, a VVVVVV inspired game written in C with SDL2</h1>
	
	
		<h5>02/23/2020</h5>
	
	
		
		
		<img src="assets/BBBBBB.gif" alt="BBBBBB game play gif" class="feature">
		
	
		
		
		<p>Recently, indie hit <a href="https://github.com/TerryCavanagh/vvvvvv">VVVVVV</a> was open sourced. VVVVVV was one of those games that always inspired me to want to make games on my own. It has a very simplistic design that focuses on fun game play and pleasing retro sounds and graphics. Many developers <a href="https://www.polygon.com/2020/1/13/21064100/vvvvvv-source-code-game-development-terry-cavanagh-release/">reacted with horror</a> when they reviewed the source code. The most egregious example being a <a href="https://github.com/TerryCavanagh/VVVVVV/blob/master/desktop_version/src/Game.cpp#L708">many hundred switch case</a>. This really made something click for me about game development, all it just takes will power and vision. So using this inspiration and started a two week long side project to make my own version of VVVVVV called <a href="https://github.com/thales17/BBBBBB">BBBBBB</a>.
</p>
		
	
		
		<h2>The Game Play</h2>
		
		
		<p>BBBBBB is a simple game where you move the player from the starting point to the goal. The goal is a white diamond shape. Once you reach the goal you will progress to the next level automatically. Players can press the space bar to flip gravity and turn upside down. If you fall off the top or bottom you will be reset to the start position. When you reach the final level the background will be blue fire! I referenced the PSX Doom Fire technique that Fabian Sanglard covered <a href="http://fabiensanglard.net/doom_fire_psx/index.html">here</a>.
</p>
		
	
		
		<h2>Inspirado</h2>
		
		
		<p>In addition to being inspired by Terry Cavanagh I also really enjoy fantasy consoles like <a href="https://www.lexaloffle.com/pico-8.php">PICO-8</a>. I like the idea of having a small sandbox to build your game in. After having <a href="https://github.com/thales17/pico8-carts">experimented</a> with PICO-8. I wanted build my own customized sandbox for games. I figured the best way to work towards that was to just build games and see what patterns emerge. So BBBBBB was built with a future fantasy console in mind. The resolution is fixed to 640x480. All of the assets in BBBBBB are generated by the code. The game is also its own level editor; by pressing <code>CTRL-E</code> you enter edit mode. In edit mode you can change the platform locations and move the player start and goal locations. Similarly, I made a small tool for drawing sprites that allows quick generation of sprite data.
</p>
		
	
		
		<h2>Graphics</h2>
		
		
		<p>The game is a fixed resolution of 640x480 pixels. The 640x480 is then subdivided into 32 columns and 24 rows. Each cell of the 32x24 grid represents game block. There are 4 different types of game blocks: nothing, platform, start and goal. There is only ever a single start and goal at a time and many different nothing blocks and platform blocks. The player is a special game entity that is sized at 10x10 pixels. Drawing of the individual entities involves subdividing their block cells into an 8x8 grid. Each block type is a drawn as single color using a something I called a grid pattern. The grid pattern is simply the indices of the active pixels in the linearized array for each block. To help with determining what those indices are I wrote a simple drawing tool. The drawing tool allowed me to click on the squares of the 8x8 grid that should be active and then press space bar to view all of the active indices. I also wrote two different background layers for the game, a simple star field and the aforementioned PSX Doom Fire (with a modified color palette).
</p>
		
	
		
		<h2>Drawing Grid Patterns</h2>
		
		
		<pre>void draw_grid_pattern(int *pattern, int len, int stride, int size, int x, int y, int r, int g, int b)
{
	int i;
	SDL_Rect rect;

	rect.w = size;
	rect.h = size;

	SDL_SetRenderDrawColor(renderer, r, g, b, 0xFF);
	for (i = 0; i &lt; len; i&#43;&#43;) {
		rect.x = x &#43; ((pattern[i] % stride) * size);
		rect.y = y &#43; ((pattern[i] / stride) * size);
		SDL_RenderFillRect(renderer, &amp;rect);
	}
}
</pre>
		
	
		
		<h2>Game Loop</h2>
		
		
		<p>The game loop is divided into three sections: handling input, updating the game state and rendering the graphics. Initially I didn't present that game via VSYNC so the game speed was un-playably fast on a modern computer. I added <code>SDL_RENDERER_PRESENTVSYNC</code> to the renderer flags to ensure that <code>SDL_RenderPresent</code> delays to make the game 60FPS. I wasn't satisfied having the renderer be in control of the game speed to I added timing to the game update function. The timing uses the <code>SDL_GetTicks</code> function to ensure that the update function is called no more than 60 times per second. This does not apply to input however, so if the game is presented without VSYNC in theory the controls could be operated at whatever frame rate the CPU could support. The game world is still only updated at 60 frames per second. Inside the update function the gravity is applied to the player and collision checks are run. The update function also determines if a sound effect needs to be played and if so plays it at that moment.
</p>
		
	
		
		<h2>Input and Controls</h2>
		
		
		<p>One area I focused on when making this game was having good feeling controls. In the past I had used SDL's event system to detect key down and key up events to mixed results. Rather than rely on the SDL event system for keyboard events I opted to poll the keyboard state manually. At first I only queried the keyboard state for the current frame which worked perfectly fine for key down events that have an infinite repeat, i.e. left and right player movement. This did prove problematic for the gravity flipping since it is a toggle. The result was that before you released the key you had already flipped an unpredictable amount of times. This had a very bad game feel. I tried many different solutions to this that involved globals before I finally landed on simply keeping the previous frames keyboard state and memory. With the last frames keyboard state I could easily say, "only flip if the space bar is down this frame and it wasn't down in the previous frame." I ended up creating two different input handlers for play mode and for edit mode. The edit input handler is the only portion of the program that polls the mouse state.
</p>
		
	
		
		<h2>Saving the Last Frame&#39;s Keyboard State</h2>
		
		
		<pre>SDL_PumpEvents();
const Uint8 *state = SDL_GetKeyboardState(NULL);

...

if (state[SDL_SCANCODE_SPACE] &amp;&amp; !last_kstate[SDL_SCANCODE_SPACE]) {
	if (!flipping) {
		should_flip = 1;
		flipping = 1;
	}
}

...

memcpy(last_kstate, state, 512);

</pre>
		
	
		
		<h2>Sound</h2>
		
		
		<p>Rather than user SDL_Mixer to playback pre recorded sound files I opted to generate the sound on the fly using SDL's sound API. Doing this was a little more complex than I initially realized since it requires you to specify all of the details for generating PCM audio. I kept it simple and created a function that can play one of 4 square wave tones for a given duration. To pick the 4 tones I experimented with different values to get a wide range of sound effects. I utilized SDL's threading capabilities to apply the duration to a given sound effect. 
</p>
		
	
		
		<h2>Closing Thoughts</h2>
		
		
		<p>Overall I am pretty happy with the results. Since this is just my take on someone else's game I didn't want to take this super far but I had a lot of fun working on it. Looking back there are a few things I know could be done better and I plan on tackling them with my next game programming project. One thing I would improve is the state management and globals. They are not organized in a way now that makes it super clear what causes what to happen in the game. I also didn't bother with any UI code like a title and game over screen. Checkout the code on <a href="https://github.com/thales17/BBBBBB">github</a>!
</p>
		
	
	</body>
</html>

